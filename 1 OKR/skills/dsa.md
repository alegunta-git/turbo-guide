## DSA roadmap
- Week1: Arrays (1D, 2D), Strings,
- Week2: HashMap, Bit Manipulations,
- Week3: LS,BS,
- Week4: 2 pointers, Prefix,
- Week5:Sliding window
- Week6:Stack, Monotonic Stack
- Week7:Queue, Dequeue, Priority Queue
- Week8: Recursion,
- Week9: LinkedList,
- Week 10: DP,
- Week 11: Trees,
- Week 12: Graphs(Types , BFS, DFS, DIJKSTRAS, Union-Find,TOPOLOGICAL SORT)

## Data Structures
* Bit Manipulation
* Arrays
* Strings 
* Stacks
* Queues
* Linked Lists
  * Single Linked List
  * Double Linked List
  * List Operations : Insertion , Deletion and Traversal
* Trees
  * Binary tree 
  * Red Black  , AVL 
  * Tree Operations : Insertion , deletion , traversal
  * Tree Traversal (* memorize inorder , preorder , postorder , level order)
* Binary Search Trees
* Heaps
* Graphs
  * DFS
  * BFS
  * Topological sort
  * Shortest Path
  * Min Spanning Tree
  * Directed / Undirected / Weighted
  * Social network analysis 
* Trie (prefix-tree searches )
* Union Find
* Hash Tables

## Sorting
* comparison and non-comparison
* Real word examples - explain why this is best choice Algorithms ( Big-o for Insert , Delete , Lookup )
* Bubble Sort,
* Insertion Sort,
* Selection Sort,
* Merge Sort,
* Quick Sort
* Counting Sort,
* Radix sort,
* Shell Sort
* Heapsort

## Search
* Linear Search
* Binary Search
* Sublist Search
* Fibonacci Search

Got it—you want to nail DSA by focusing on the 20 % of concepts that deliver 80 % of the results. Here’s a quick “80/20” cheat sheet:

*Core topics (≈20 % of DSA)*
- *Arrays & Strings* – sliding window, two‑pointer, prefix sums
- *Linked Lists* – fast/slow pointers, reversal, cycle detection
- *Stacks & Queues* – monotonic stack, BFS/DFS basics
- *Trees* – binary tree traversals, BST operations, depth‑first recursion
- *Graphs* – BFS/DFS, topological sort, shortest‑path (Dijkstra/BFS)
- *Recursion & Backtracking* – permutations, subsets, N‑Queens pattern
- *Dynamic Programming* – classic 1‑D/2‑D DP, knapsack, longest‑increasing subsequence
- *Sorting & Searching* – quicksort/merge sort, binary search variants
- *Hashing* – frequency maps, two‑sum pattern, handling collisions

*How to use the 80/20 rule*
1. *Pick one core topic* and solve 5–6 “signature” problems that cover all its patterns.
2. *Generalize*: after each problem, write a one‑sentence “template” you can reuse.
3. *Rotate*: spend a week on each topic, then revisit with mixed‑topic sets to cement connections.
4. *Time‑box*: 30 min to solve, 15 min to review the optimal solution—focus on the idea, not just the code.

*Quick starter plan (2 weeks)*
- *Day 1‑2:* Arrays & Strings – sliding window, two‑pointer.
- *Day 3‑4:* Linked Lists – reversal, cycle detection.
- *Day 5‑6:* Stacks/Queues – monotonic stack, BFS basics.
- *Day 7‑8:* Trees – inorder traversal, BST insert/search.
- *Day 9‑10:* Graphs – BFS/DFS, topological sort.
- *Day 11‑12:* Recursion – subsets, permutations.
- *Day 13‑14:* DP – knapsack, LIS, edit distance.

Finish each day with a one‑sentence summary of the pattern you learned. That repetition is the “20 % effort” that yields the “80 % payoff.”
